<html>
  <head>
    <title>A Threejs Scene</title>
    <style>
       
      body {
        /* set margin to 0 and overflow to hidden, to go fullscreen */
        margin: 0;
        overflow: hidden;

        background: #cefffa;
        background: -moz-linear-gradient(top,  #cefffa 0%, #f2b51d 89%);
        background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#cefffa), color-stop(89%,#f2b51d));
        background: -webkit-linear-gradient(top,  #cefffa 0%,#f2b51d 89%);
        background: -o-linear-gradient(top,  #cefffa 0%,#f2b51d 89%);
        background: -ms-linear-gradient(top,  #cefffa 0%,#f2b51d 89%);
        background: linear-gradient(to bottom,  #cefffa 0%,#f2b51d 89%);

        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#cefffa', endColorstr='#f2b51d',GradientType=0 );
      }

    </style>

  </head>

  <body>
    
    <script type="text/javascript" src="js/three.min.js"></script>
    <script type="text/javascript" src="js/tween.min.js"></script>
    <script type="text/javascript" src="js/ParticleEngine.js"></script>
    <script type="text/javascript" src="js/stats.min.js"></script>
    <script type="text/javascript" src="js/FirstPersonControls.js"></script>
    <script type="text/javascript" src="js/JSONLoader.js"></script>
    <script type="text/javascript" src="js/OculusRiftEffect_HUD.js"></script>
    <script type="text/javascript" src="js/PathCamera.js"></script>
    <script type="text/javascript" src="js/DK2Controls.js"></script>
    <script type="text/javascript" src="js/dat.gui.min.js"></script>
    <script src="js/socket.io.js"></script>
    <script type="text/javascript">

      //Global variables.

      var socket = io.connect('http://localhost:8888');

      // body components
      var container, content;

      var SUN_LIGHT = 0xffa573;
      var RAIN_LIGHT = 0x5596E6;

      var textContainer;

      var scene, renderer, controls;
      var camera, pathCamera;
      var HUDscene, HUDcamera;

      var path;
      var step = 0;         // camera step

      // hud elments
      var HUDisVisible = true;
      var HUDElementMaterialColor;
      var pointerMesh;

      var scene_mesh;
      var light;
      var ambientLightColor = SUN_LIGHT;

      var loader;
      var oculusRenderer;
      var clock = new THREE.Clock();
      var delta;

      var pathEnabled = false; // set to true for runner camera; can be changed at runtime pressing shift

      // is it raining?
      var isRaining = false;
      var rain;

      var cube;
      var isTweening = false;

      // game state
      var HUDPauseMaterial;
      var pause = true;

      var controlGUI;

      function init() {


      /* web socket */
      socket.on('message',function(data){
        console.log('message received is ' + data);
      });

      // creating body
      // ---------------------------------------------

      container = document.createElement('div');
      container.id = "container";

      content = document.createElement('div');
      content.id = "content";
      
      container.appendChild(content);

      document.body.appendChild(container);

      // ---------------------------------------------

      // setup the control object for the control gui
      controlGUI = new function() {
          this.oculusEnabled = false;
          this.HUDenabled = HUDisVisible;
      };
      addControlGui(controlGUI);

      // the overlay will fade in when 'esc' is released
      window.onkeyup = function(e) {
          var key = e.keyCode ? e.keyCode : e.which;

          // 27 = esc
          if (key == 27) {
            if(pause) 
              pause = false;
            else
              pause = true;
          }

          // 16 = shift
          if (key == 16) {
            switchCamera();
          }
      }

      function switchCamera() {
        console.log("switch camera");

        if(pathEnabled)
          pathEnabled = false;
        else
          pathEnabled = true;

        setControls();
      }

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      scene = new THREE.Scene();

      // create a render, sets the background color and the size
      renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
      renderer.setClearColor( 0xa7fae6, 1 );
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMapEnabled = true;

      // Here is the oculusRenderer for the Oculus Rift
        // worldScale 100 means that 100 Units == 1m
      oculusRenderer = new THREE.OculusRiftEffect( renderer, {worldScale: 100} );
      oculusRenderer.setSize( window.innerWidth, window.innerHeight );

      //add track
var sampleClosedSpline = new THREE.ClosedSplineCurve3( [
new THREE.Vector3(-0.33,0.33,2.14),
new THREE.Vector3(-0.58,0.68,-2.94),
new THREE.Vector3(-4.7,0.53,-5.09),
new THREE.Vector3(-8.29,0.09,-3.79),
new THREE.Vector3(-9.33,0.69,-2.15),
new THREE.Vector3(-8.0,0.63,1.31),
new THREE.Vector3(-7.21,0.41,4.3),
new THREE.Vector3(-0.01,0.13,7.23),
new THREE.Vector3(-0.1,0.44,4.61)
] );
      
      pathCamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 1000 );
      path = new PathCamera(pathCamera,sampleClosedSpline);

     
      var sampleClosedSpline = new THREE.ClosedSplineCurve3( [
        new THREE.Vector3(2, 0, -2),
        new THREE.Vector3(2, 0, 2),
        new THREE.Vector3(-2, 0, 2),
        new THREE.Vector3(-2, 0, -2),
      ] );

      // create cameras.
      // PathCamera will follow the defined path and be controlled by PathCamera.js
      // camera is the normal camera and  will be controlled by FirstPersonControls.js/DK2Controls.js
      pathCamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 1000 );
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 30);

      path = new PathCamera(pathCamera, sampleClosedSpline);

      // position and point the default camera to the center of the scene
      camera.position.x = 0;
      camera.position.y = 1;
      camera.position.z = 0;

      // --- hud
      // create a scene that will hold all hud elements and an ortho camera to always show them on top of the game scene
      HUDscene = new THREE.Scene();
      HUDcamera = new THREE.OrthographicCamera(-window.innerWidth, window.innerWidth, window.innerHeight, -window.innerHeight, 0.01, 10000);

      // load a sample texture
      var texture = THREE.ImageUtils.loadTexture("textures/ui.png");

      //  //add the path geometry to test
      // var curveGeometry = new THREE.TubeGeometry(sampleClosedSpline, 200, 10, 1, true); //true == closed curve
      // var pathMesh = new THREE.Mesh(curveGeometry,
      //           new THREE.MeshLambertMaterial( { color : 0xff0000 } ));
      // scene.add(pathMesh);

      //add particle system for raining
      var materialColor = new THREE.MeshBasicMaterial({  map: texture });
      materialColor.transparent = true
      materialColor.opacity = 1;
      var hudElement = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), materialColor);

      HUDElementMaterialColor = new THREE.MeshBasicMaterial({  map: texture });
      HUDElementMaterialColor.transparent = true
      HUDElementMaterialColor.opacity = 1;
      var hudElement = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), HUDElementMaterialColor);
      hudElement.scale.set(window.innerWidth / 2, window.innerHeight / 2, 1);
      hudElement.position.z = -0.01;
      hudElement.position.x = 1000;
      HUDscene.add(hudElement);

      var texturePath = THREE.ImageUtils.loadTexture("textures/texture.png");

      var HUDPathMaterialColor = new THREE.MeshBasicMaterial({  map: texturePath });
      HUDPathMaterialColor.transparent = true
      HUDPathMaterialColor.opacity = 1;
      var hudElement = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), HUDPathMaterialColor);

      hudElement.scale.set(window.innerWidth / 2, window.innerHeight / 2, 1);
      hudElement.position.z = -0.01;
      hudElement.position.x = 1000;
      hudElement.position.y = 500;
      HUDscene.add(hudElement);

      var texturePath = THREE.ImageUtils.loadTexture("textures/pointer.png");

      var HUDPointerMaterial = new THREE.MeshBasicMaterial({  map: texturePath });
      HUDPointerMaterial.transparent = true
      HUDPointerMaterial.opacity = 1;
      pointerMesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), HUDPointerMaterial);
      pointerMesh.scale.set(20, 20, 1);
      pointerMesh.position.z = -0.01;
      pointerMesh.position.x = 1000;
      pointerMesh.position.y = 500;
      HUDscene.add(pointerMesh);

      var pauseTexture = THREE.ImageUtils.loadTexture("textures/texture.png");
      //pauseTexture.repeat.x = 0;
      //pauseTexture.repeat.y = 0;

      HUDPauseMaterial = new THREE.MeshBasicMaterial({ color: "black", map: pauseTexture });
      HUDPauseMaterial.transparent = true
      HUDPauseMaterial.opacity = 1;
      var HUDPause = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), HUDPauseMaterial);
      HUDPause.scale.set(window.innerWidth*2, window.innerHeight*2, 1);
      HUDPause.position.z = -0.01;
      HUDscene.add(HUDPause);

      // ---

      // add a random cube to the scene
      var cubeGeometry = new THREE.CubeGeometry(1, 1, 1);
      var cubeMaterial = new THREE.MeshLambertMaterial({
         color: "red"
         });
      cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      cube.castShadow = true;
      cube.position.z = -5;
      cube.position.y = 1;
      cube.position.x = 3;
      scene.add(cube);

      // add particle system for raining to the scene

      rain = new ParticleEngine();
      if(isRaining)
        rain.start();



      // create a render, sets the background color and the size
      renderer = new THREE.WebGLRenderer({antialias:true,alpha: true});
      renderer.setClearColor( 0xa7fae6, 1 );
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMapEnabled = true;
      //shadow antialiasing
      renderer.shadowMapType = THREE.PCFSoftShadowMap;

      // Here is the oculusRenderer for the Oculus Rift
        // worldScale 100 means that 100 Units == 1m
      oculusRenderer = new THREE.OculusRiftEffect( renderer, {worldScale: 100} );
      oculusRenderer.setSize( window.innerWidth, window.innerHeight );

      //Create a light

      // lights

      light = new THREE.SpotLight(0xffa573);
      light.position.set(0, 10, 50);
      light.shadowCameraNear = 50;
      light.shadowMapWidth = light.shadowMapHeight = 2048;
      light.shadowCameraFar = 5000;
      light.castShadow = true;
      scene.add(light);

      var ambientLight = new THREE.AmbientLight( ambientLightColor );
      scene.add(ambientLight );

      // if is raining change light color
      if(isRaining)
        ambientLightColor = RAIN_LIGHT;
      else
        ambientLightColor = SUN_LIGHT;

      // add fog
      scene.fog = new THREE.FogExp2( 0xFFFFFF, 0.1);

      // load scene model
      loader = new THREE.JSONLoader();
      loadScene();


      // position and point the default camera to the center of the scene
      camera.position.x = -5.95;
      camera.position.y = 1;
      camera.position.z = 5.78;
      // camera.position = new THREE.Vector3(-5.95,0.46,-5.78);

      // Oculus DK2 controls

      if(oculusEnabled == true)
      controls = new THREE.DK2Controls(pathEnabled === true? pathCamera:camera);
      else{
        controls = new THREE.FirstPersonControls( pathEnabled === true? pathCamera:camera);
        controls.movementSpeed = 2;
        controls.lookSpeed = 0.04;
        controls.lookVertical = false;  
      }

      // // add fps stats

      // debug controls
      setControls();
      // add fps stats

      addStats();

      // add the output of the renderer to the html element
      content.appendChild(renderer.domElement);

      // call the render function, after the first render, interval is determined by requestAnimationFrame
      render(0.016);
    }

    function addControlGui(controlObject) {
        var gui = new dat.GUI();
        gui.add(controlObject, 'oculusEnabled', false);
        gui.add(controlObject, 'HUDenabled', true);
    }

    function setControls() {
      // Oculus DK2 controls
      if(controlGUI.oculusEnabled == true)
        controls = new THREE.DK2Controls(pathEnabled === true ? pathCamera : camera);
      else {
        controls = new THREE.FirstPersonControls( pathEnabled === true ? pathCamera : camera);
        controls.movementSpeed = 2;
        controls.lookSpeed = 0.02;
        controls.lookVertical = true;  
      }
    }
    
    function render(dt) {

      // updating the position and orientation of the camera
      if ( controls.moveForward ) {
        path.takeStep(step, step+2, 400, controlGUI.oculusEnabled);
        step += 2;
      }
        
      if ( controls.moveBackward ) {
        if(step > 0) {
          path.takeStep(step, step-2, 400, controlGUI.oculusEnabled);
          step -= 2; 
        }
      }

      delta = clock.getDelta();

      controls.update(delta);
      // ---

      // used in PathCamera
      TWEEN.update();

      // update rain
      rain.update(dt);

      // show/hide pause
      if(pause) {
        // show pause
        if(HUDPauseMaterial.opacity < 0.5)
          HUDPauseMaterial.opacity = HUDPauseMaterial.opacity + 0.1;
        else
          HUDPauseMaterial.opacity = 0.5;
      }
      else {
        // hide pause
        if(HUDPauseMaterial.opacity > 0.1)
          HUDPauseMaterial.opacity = HUDPauseMaterial.opacity - 0.1;
        else
          HUDPauseMaterial.opacity = 0;
      }

      // show/hide hud
      updateHUDVisibility();

      // update pointer on map
      updatePointer();

      // update
      renderer.autoClear = false;
      if(controlGUI.oculusEnabled == true) {
        oculusRenderer.render( scene, pathEnabled === true ? pathCamera : camera, HUDscene);
      }
      else {
        // if we just switched to the normal renderer from the oculusRenderer, we have to reset render area size
        renderer.setSize(window.innerWidth, window.innerHeight);

        renderer.clear();
        renderer.render(scene, (pathEnabled === true ? pathCamera : camera));
        renderer.render(HUDscene, HUDcamera);
      }


      //load the scene
      function loadScene(){
          loader.load("./models/scene2.js",
          function(model,materials){
            scene_mesh = new THREE.Mesh(model,new THREE.MeshFaceMaterial( materials ));
            scene_mesh.name = 'scene';
            scene_mesh.receiveShadow = true;
            scene_mesh.castShadow = true;
            scene.add(scene_mesh);
          });
      }
            /**
       * Function handles the resize event. This make sure the camera and the renderer
       * are updated at the correct moment.
       */
      function handleResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          oculusRenderer.setSize( window.innerWidth, window.innerHeight );
          renderer.setSize(window.innerWidth, window.innerHeight);
      }     

      window.onload = init;
      // calls the handleResize function when the window is resized
      window.addEventListener('resize', handleResize, false);

    </script>
  </body>
</html>
